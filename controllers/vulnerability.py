# -*- coding: utf-8 -*-

"""
    Sahana Eden Vulnerability Controller
"""

module = request.controller
resourcename = request.function

if not settings.has_module(module):
    raise HTTP(404, body="Module disabled: %s" % module)

# -----------------------------------------------------------------------------
def index():
    """ Module Home Page: Map """

    # This module uses it's own Theme
    settings.base.theme = "Vulnerability"

    # Additional scripts
    append = s3.scripts.append
    append("/%s/static/scripts/yepnope.1.5.4-min.js" % appname)
    if s3.debug:
        append("/%s/static/scripts/jquery.ui.selectmenu.js" % appname)
        append("/%s/static/scripts/TypeHelpers.js" % appname)
        append("/%s/static/scripts/S3/s3.vulnerability.js" % appname)
    else:
        append("/%s/static/scripts/S3/s3.vulnerability.min.js" % appname)

    js_global = []
    append = js_global.append

    # Get the L0 gdata, hdata & summary vdata
    gdata, hdata, vdata = l0()

    # Get the default location to open the map
    bounds = None
    root_org = auth.root_org()
    start = False
    if root_org:
        otable = s3db.org_organisation
        ttable = s3db.gis_location_tag
        gtable = s3db.gis_location
        query = (otable.id == root_org) & \
                (ttable.tag == "ISO2") & \
                (ttable.value == otable.country)
        r = db(query).select(ttable.location_id,
                             limitby=(0, 1)).first()
        if r and r.location_id in countries:
            start = True
            append('''start=%s''' % r.location_id)
            # Add the child L1 gdata & summary vdata
            l1(r.location_id, gdata, vdata)
            # Keep a memory of the fact that we have already downloaded this gdata
            session.s3.gdata_l0 = [r.location_id]
    if not start:
        session.s3.gdata_l0 = []
        append('''start=""''')

    dumps = json.dumps
    script = '''
gdata=%s
hdata=%s
vdata=%s
''' % (dumps(gdata), dumps(hdata), dumps(vdata))
    append(script)

    
    # Get the list of indicators
    itable = s3db.vulnerability_indicator
    query = (itable.deleted == False)
    rows = db(query).select(itable.name,
                            itable.description,
                            itable.parameter_id,
                            orderby=itable.name)
    indicators = OrderedDict()
    for row in rows:
        indicators[row.parameter_id] = dict(n=row.name,
                                            d=row.description)
    append('''idata=%s''' % json.dumps(indicators))

    s3.js_global.append("".join(js_global))

    # Session vars to know which gdata has already been downloaded to clients
    session.s3.gdata_l1 = []
    session.s3.gdata_l2 = []
    session.s3.gdata_l3 = []
    session.s3.gdata_l4 = []

    response.view = "vulnerability/map.html"
    return dict()

# -----------------------------------------------------------------------------
def l0():
    """
        Return gdata (Geometries), hdata (Hierarchy Labels) &
        summary vdata (Resilience) for all Countries
        - used only by the initial map load
    """

    countries = ["TL", "VN"]
    gtable = s3db.gis_location
    ttable = s3db.gis_location_tag
    htable = s3db.gis_hierarchy
    query = (gtable.id == ttable.location_id) & \
            (ttable.tag == "ISO2") & \
            (ttable.value.belongs(countries)) & \
            (gtable.id == htable.location_id)
    atable = s3db.vulnerability_aggregated_indicator
    stable = s3db.stats_aggregate
    lquery = (atable.name == "Resilience") & \
             (stable.parameter_id == atable.parameter_id) & \
             (stable.agg_type == 4) & \
             (stable.location_id == gtable.id)
    left = stable.on(lquery)
    gdata = {}
    hdata = {}
    vdata = {}

    ids = []
    append = ids.append
    if settings.get_gis_spatialdb():
        # Do the Simplify & GeoJSON direct from the DB
        rows = db(query).select(gtable.id,
                                gtable.name,
                                gtable.the_geom.st_simplify(0.001).st_asgeojson(precision=4).with_alias("geojson"),
                                htable.L1,
                                htable.L2,
                                htable.L3,
                                htable.L4,
                                stable.date,
                                stable.mean,
                                orderby=~stable.date,
                                left=left)
        for row in rows:
            id = row[gtable].id
            if id in ids:
                # We're only interested in the most recent data per location
                continue
            append(id)
            _grow = row[gtable]
            gdata[id] = _grow.geojson
            _hrow = row[htable]
            hdata[id] = dict(l1 = _hrow.L1,
                             l2 = _hrow.L2,
                             l3 = _hrow.L3,
                             l4 = _hrow.L4,
                             )
            mean = row[stable].mean
            if mean is None:
                resilience = 0
            else:
                resilience = int(round(mean, 0))
            vdata[id] = dict(r = resilience,
                             n = _grow.name,
                             l = 0,
                             )
    else:
        rows = db(query).select(gtable.id,
                                gtable.name,
                                gtable.wkt,
                                htable.L1,
                                htable.L2,
                                htable.L3,
                                htable.L4,
                                stable.date,
                                stable.mean,
                                orderby=~stable.date,
                                left=left)
        simplify = gis.simplify
        for row in rows:
            id = row[gtable].id
            if id in ids:
                # We're only interested in the most recent data per location
                continue
            append(id)
            _grow = row[gtable]
            gdata[id] = simplify(_grow.wkt, output="geojson")
            _hrow = row[htable]
            hdata[id] = dict(l1 = _hrow.L1,
                             l2 = _hrow.L2,
                             l3 = _hrow.L3,
                             l4 = _hrow.L4,
                             )
            mean = row[stable].mean
            if mean is None:
                resilience = None
            else:
                resilience = int(round(mean, 0))
            vdata[id] = dict(r = resilience,
                             n = _grow.name,
                             l = 0,
                             )

    return gdata, hdata, vdata

# -----------------------------------------------------------------------------
def l1(id, gdata, vdata):
    """
        Update gdata (Geometries) & summary vdata (Resilience) for all
        child L1s of the starting country
        - used only by the initial map load
    """

    gtable = db.gis_location
    query = (gtable.parent == id) & \
            (gtable.level == "L1")
    atable = db.vulnerability_aggregated_indicator
    stable = db.stats_aggregate
    rquery = (atable.name == "Resilience") & \
             (stable.parameter_id == atable.parameter_id) & \
             (stable.agg_type == 4)
    if settings.get_gis_spatialdb():
        # Do the Simplify & GeoJSON direct from the DB
        rows = db(query).select(gtable.id,
                                gtable.name,
                                gtable.the_geom.st_simplify(0.001).st_asgeojson(precision=4).with_alias("geojson"),
                                )
        for row in rows:
            query = rquery & (stable.location_id == row.id)
            _row = db(query).select(stable.date,
                                    stable.mean,
                                    orderby=~stable.date).first()
            gdata[row.id] = row.geojson
            resilience = None
            if _row and _row.mean is not None:
                resilience = int(round(_row.mean, 0))
            vdata[row.id] = dict(r = resilience,
                                 n = row.name,
                                 l = 1,
                                 f = id,
                                 )
    else:
        rows = db(query).select(gtable.id,
                                gtable.name,
                                gtable.wkt,
                                )
        simplify = gis.simplify
        for row in rows:
            query = rquery & (stable.location_id == row.id)
            _row = db(query).select(stable.date,
                                    stable.mean,
                                    orderby=~stable.date).first()
            geojson = simplify(row.wkt, output="geojson")
            gdata[row.id] = row.geojson
            resilience = None
            if _row and _row.mean is not None:
                resilience = int(round(_row.mean, 0))
            vdata[row.id] = dict(r = resilience,
                                 n = row.name,
                                 l = 1,
                                 f = id,
                                 )

    return

# -----------------------------------------------------------------------------
def gdata():
    """
        Return the geometries for the children of a location
    """

    try:
        id = request.args[0]
    except:
        raise HTTP(400)

    try:
        level = "L%s" % request.args[1]
    except:
        raise HTTP(400)

    if (level == "L1" and id in session.s3.gdata_l0) or \
       (level == "L2" and id in session.s3.gdata_l1) or \
       (level == "L3" and id in session.s3.gdata_l2) or \
       (level == "L4" and id in session.s3.gdata_l3):
       response.headers["Content-Type"] = "application/json"
       # We already have this data cached
       return ''

    gtable = s3db.gis_location
    query = (gtable.parent == id) & \
            (gtable.level == level) & \
            (gtable.deleted != True)
    data = {}
    if settings.get_gis_spatialdb():
        # Do the Simplify & GeoJSON direct from the DB
        rows = db(query).select(gtable.id,
                                gtable.the_geom.st_simplify(0.001).st_asgeojson(precision=4).with_alias("geojson"),
                                )
        for row in rows:
            data[row.id] = row.geojson
    else:
        rows = db(query).select(gtable.id,
                                gtable.wkt,
                                )
        simplify = gis.simplify
        for row in rows:
            geojson = simplify(row.wkt, output="geojson")
            data[row.id] = geojson

    script = '''n=%s''' % json.dumps(data)
    response.headers["Content-Type"] = "application/json"
    return script

# -----------------------------------------------------------------------------
def vdata():
    """
        Return JSON of the Vulnerability data for a location
        - for display in Map Popups and the Drawer
    """

    try:
        id = request.args[0]
    except:
        raise HTTP(400)

    gtable = s3db.gis_location
    query = (gtable.id == id)
    row = db(query).select(gtable.name,
                           gtable.level,
                           gtable.parent,
                           gtable.L0,
                           gtable.L1,
                           gtable.L2,
                           gtable.L3,
                           limitby=(0, 1)).first()
    if not row or not row.level:
        return ""
    script = ""
    data = dict(
            n = row.name,
            f = row.parent,
            )
    vdata = {}
    ids = []
    append = ids.append
    level = row.level
    l0_name = row.L0
    l1_name = row.L1
    l2_name = row.L2
    l3_name = row.L3
    atable = s3db.vulnerability_aggregated_indicator
    stable = s3db.stats_aggregate
    if level != "L4":
        # We need to read the names & resilience of the next level down for the popup dropdown selector
        _level = int(level[1]) + 1
        query = (gtable.parent == id) & \
                (gtable.level == "L%s" % _level) & \
                (gtable.deleted != True)
        lquery = (atable.name == "Resilience") & \
                 (stable.parameter_id == atable.parameter_id) & \
                 (stable.agg_type == 4) & \
                 (stable.location_id == gtable.id)
        left = stable.on(lquery)
        rows = db(query).select(gtable.id,
                                gtable.name,
                                stable.date,
                                stable.mean,
                                orderby=~stable.date,
                                left=left)
        for row in rows:
            _id = row[gtable].id
            if _id in ids:
                # We're only interested in the most recent data per location
                continue
            append(_id)
            mean = row[stable].mean
            if mean is None:
                resilience = 0
            else:
                resilience = int(round(mean, 0))
            vdata[_id] = dict(r = resilience,
                              n = row[gtable].name,
                              l = _level,
                              f = id,
                              )

    # Get the Resilience
    query = (atable.name == "Resilience") & \
            (stable.parameter_id == atable.parameter_id) & \
            (stable.agg_type == 4) & \
            (stable.location_id == gtable.id)
    r = db(query).select(stable.date,
                         stable.mean,
                         orderby=~stable.date,
                         limitby=(0, 1)).first()
    if not r or r.mean is None:
        resilience = 0
    else:
        resilience = int(round(r.mean, 0))
    data["r"] = resilience

    # Get the list of indicators
    indicator_pids = s3db.vulnerability_ids()
    # Get the aggregated data for this location for all indicators
    query = (stable.location_id == id) & \
            (stable.parameter_id.belongs(indicator_pids))
    rows = db(query).select(stable.count,
                            stable.parameter_id,
                            stable.min,
                            stable.max,
                            stable.median)
    indicator_data = {}
    # How many L4s have reported?
    count = 0
    for row in rows:
        if row.count > count:
            count = row.count
        indicator_data[row.parameter_id] = dict(
                        min = row.min,
                        max = row.max,
                        median = row.median,
                       )
    data["i"] = indicator_data
    data["c"] = count

    # Total number of L4s in this region
    # @ToDo: Below L0 we cannot guarantee uniqueness of Lx names
    query = (gtable.level == "L4") & \
            (gtable.deleted != True)
    if level == "L0":
        query = query & (gtable.L0 == l0_name)
    elif level == "L1":
        query = query & (gtable.L0 == l0_name) & \
                        (gtable.L1 == l1_name)
    elif level == "L2":
        query = query & (gtable.L0 == l0_name) & \
                        (gtable.L1 == l1_name) & \
                        (gtable.L2 == l2_name)
    elif level == "L3":
        query = query & (gtable.L0 == l0_name) & \
                        (gtable.L1 == l1_name) & \
                        (gtable.L2 == l2_name) & \
                        (gtable.L3 == l3_name)
    t = db(query).count()
    data["t"] = t

    # Calculate Quality
    if count == 0 or t == 0:
        q = "p"
    else:
        q = count/t * 100
        if q < 25:
            q = "p"
        elif q < 50:
            q = "f"
        elif q < 75:
            q = "m"
        else:
            q = "s"
    data["q"] = q

    # Get the Demographic data for the location
    dtable = s3db.stats_demographic
    ddtable = s3db.stats_demographic_data
    stable = s3db.doc_source_entity
    query = (dtable.name == "Population") & \
            (ddtable.location_id == id) & \
            (ddtable.parameter_id == dtable.parameter_id) & \
            (ddtable.source_id == stable.source_id)
    row = db(query).select(ddtable.value,
                           ddtable.date.max(),
                           stable.name,
                           limitby=(0, 1)).first()
    p = row[ddtable].value
    if p:
        p = int(p)
    data["p"] = p
    data["s"] = row[stable].name

    vdata[id] = data
    script = '''n=%s\n''' % json.dumps(vdata)
    response.headers["Content-Type"] = "application/json"
    return script

# -----------------------------------------------------------------------------
def report():
    """ Not a REST Controller """

    request = current.request
    if len(request.args) == 1:
        if request.args[0] == "filter":
            filter_request = request.post_vars
            doctable = s3db.doc_document
            query = (doctable.deleted != True)
            try:
                loc_id = int(filter_request["location_id"])
            except:
                loc_id = -1
            if loc_id != -1:
                query &= (doctable.location_id == loc_id)
            if filter_request["from_date"]:
                query &= (doctable.date >= filter_request["from_date"])
            if filter_request["to_date"]:
                query &= (doctable.date <= filter_request["to_date"])
            # @todo : Need to add a link to the type (join on source_id and then
            #         look at the instance type?)
            report_data = {}
            report_data["Approval"] = [1, 2, 3]
            report_data["VCA"] = [4, 5, 6, 7, 8]
            report_data["Reports"] = [9, 10, 11, 12, 13, 14]

            response.headers["Content-Type"] = "application/json"
            return json.dumps(report_data)

    filter = {}
    date_widget = S3DateWidget(future=0)
    to_date = Field("to_date")
    to_date._tablename = ""
    from_date = Field("from_date")
    from_date._tablename = ""
    filter["to_date"] = str(date_widget(to_date, None))
    filter["from_date"] = str(date_widget(from_date, None))
    report_data = {}
    report_data["Approval"] = [1, 2, 3]
    report_data["VCA"] = [4, 5, 6, 7, 8]
    report_data["Reports"] = [9, 10, 11, 12, 13, 14]
    data_dict = {"filter" : filter,
                 "report" : report_data,
                 }
    data = json.dumps(data_dict)

    response.headers["Content-Type"] = "application/json"
    return data

# -----------------------------------------------------------------------------
def indicator():
    """ REST Controller """

    return s3_rest_controller()

# -----------------------------------------------------------------------------
def aggregated_indicator():
    """ REST Controller """

    return s3_rest_controller()

# -----------------------------------------------------------------------------
def data():
    """ REST Controller """

    return s3_rest_controller()

# END =========================================================================
