# -*- coding: utf-8 -*-

"""
    Sahana Eden Vulnerability Controller
"""

module = request.controller
resourcename = request.function

if not settings.has_module(module):
    raise HTTP(404, body="Module disabled: %s" % module)

# @ToDo: deployment_setting
countries = ["TL", "VN"]

# -----------------------------------------------------------------------------
def index():
    """ Module Home Page: Map """

    # This module uses it's own Theme
    settings.base.theme = "Vulnerability"

    # Additional scripts
    append = s3.scripts.append
    append("/%s/static/scripts/yepnope.1.5.4-min.js" % appname)
    if s3.debug:
        append("/%s/static/scripts/jquery.ui.selectmenu.js" % appname)
        append("/%s/static/scripts/TypeHelpers.js" % appname)
        append("/%s/static/scripts/S3/s3.vulnerability.js" % appname)
        append("/%s/static/scripts/S3/s3.dataTables.js" % appname)
        append("/%s/static/scripts/jquery.dataTables.js" % appname)
        append("/%s/static/scripts/jquery.dataTables.fnSetFilteringDelay.js" % appname)
    else:
        append("/%s/static/scripts/S3/s3.vulnerability.min.js" % appname)
        append("/%s/static/scripts/S3/dataTables.min.js" % appname)

    js_global = []
    append = js_global.append

    # Get the L0 hdata & summary vdata
    hdata, vdata = l0()

    # Get the default location to open the map
    bounds = None
    root_org = auth.root_org()
    start = False
    if root_org:
        otable = s3db.org_organisation
        ttable = s3db.gis_location_tag
        gtable = s3db.gis_location
        query = (otable.id == root_org) & \
                (ttable.tag == "ISO2") & \
                (ttable.value == otable.country)
        r = db(query).select(ttable.location_id,
                             limitby=(0, 1)).first()
        if r and r.location_id in countries:
            start = True
            append('''start=%s''' % r.location_id)
            # Add the child L1 summary vdata
            l1(r.location_id, vdata)
    if not start:
        append('''start=""''')

    dumps = json.dumps
    script = '''
hdata=%s
vdata=%s
''' % (dumps(hdata), dumps(vdata))
    append(script)

    # Get the list of indicators
    itable = s3db.vulnerability_indicator
    query = (itable.deleted == False)
    rows = db(query).select(itable.name,
                            itable.description,
                            itable.parameter_id,
                            orderby=itable.name)
    indicators = OrderedDict()
    for row in rows:
        indicators[row.parameter_id] = dict(n=row.name,
                                            d=row.description)
    append('''idata=%s''' % json.dumps(indicators))

    s3.js_global.append("".join(js_global))


    from s3.s3utils import S3DataTable
    resource = s3db.resource("doc_source_entity")
    list_fields = ["id",
                   "date",
                   "location_id",
                   "location_id$L3",
                   "status",
                   "source_type_id",
                   "created_by",
                   "modified_by",
                   ]
    rfields = resource.resolve_selectors(list_fields)[0]
    dt = S3DataTable(rfields, [])
    report = dt.html(#filteredrows,
                     #filteredrows,
                     "report",
                     dt_pagination="false",
                     dt_bFilter="false",
                     dt_sDom="t",
                     dt_group=[4,3],
                     dt_group_totals=[],
                     dt_ajax_url=URL(c="vulnerability",
                                     f="report",
                                     extension="aaData",
                                     vars={"id": "report"},
                                     ),
                     dt_action_col = -1,
                     dt_shrink_groups = "accordion"
                     )
    s3.report = report

    response.view = "vulnerability/map.html"
    return dict()

# -----------------------------------------------------------------------------
def init():
    """
        Create the static GeoJSONs that the app needs
    """

    gis.export_admin_areas(countries)
    return "complete"

# -----------------------------------------------------------------------------
def l0():
    """
        Return hdata (Hierarchy Labels) & summary vdata (Resilience) for all Countries
        - used only by the initial map load
    """

    gtable = s3db.gis_location
    ttable = s3db.gis_location_tag
    htable = s3db.gis_hierarchy
    query = (gtable.id == ttable.location_id) & \
            (ttable.tag == "ISO2") & \
            (ttable.value.belongs(countries)) & \
            (gtable.id == htable.location_id)
    stable = s3db.stats_aggregate
    lquery = (stable.parameter_id == s3db.vulnerability_resilience_id()) & \
             (stable.agg_type == 4) & \
             (stable.location_id == gtable.id)
    left = stable.on(lquery)
    hdata = {}
    vdata = {}

    ids = []
    append = ids.append
    rows = db(query).select(gtable.id,
                            gtable.name,
                            htable.L1,
                            htable.L2,
                            htable.L3,
                            htable.L4,
                            stable.date,
                            stable.mean,
                            orderby=~stable.date,
                            left=left)
    for row in rows:
        id = row[gtable].id
        if id in ids:
            # We're only interested in the most recent data per location
            continue
        append(id)
        _grow = row[gtable]
        _hrow = row[htable]
        hdata[id] = dict(l1 = _hrow.L1,
                         l2 = _hrow.L2,
                         l3 = _hrow.L3,
                         l4 = _hrow.L4,
                         )
        mean = row[stable].mean
        if mean is None:
            resilience = 0
        else:
            resilience = int(round(mean, 0))
        vdata[id] = dict(r = resilience,
                         n = _grow.name,
                         l = 0,
                         )

    return hdata, vdata

# -----------------------------------------------------------------------------
def l1(id, vdata):
    """
        Update summary vdata (Resilience) for all child L1s of the start country
        - used only by the initial map load
    """

    gtable = db.gis_location
    query = (gtable.parent == id) & \
            (gtable.level == "L1")
    atable = db.vulnerability_aggregated_indicator
    stable = db.stats_aggregate
    rquery = (atable.name == "Resilience") & \
             (stable.parameter_id == atable.parameter_id) & \
             (stable.agg_type == 4)
    rows = db(query).select(gtable.id,
                            gtable.name,
                            )
    for row in rows:
        query = rquery & (stable.location_id == row.id)
        _row = db(query).select(stable.date,
                                stable.mean,
                                orderby=~stable.date).first()
        resilience = None
        if _row and _row.mean is not None:
            resilience = int(round(_row.mean, 0))
        vdata[row.id] = dict(r = resilience,
                             n = row.name,
                             l = 1,
                             f = id,
                             )

    return

# -----------------------------------------------------------------------------
def vdata():
    """
        Return JSON of the Vulnerability data for a location
        - for display in Map Popups and the Drawer

        vdata = { id : {
                        'n' : name,
                        'l' : level,
                        'f' : parent,
                        'r' : resilience,
                        'i' : indicator data,
                        'c' : count (how many L4s reported in this region),
                        't' : count (how many L4s total in this region),
                        'q' : quality,
                        'p' : population,
                        's' : source (for population),
                        'b' : population breakdown (for L4s),
                        }
                 }
    """

    try:
        id = request.args[0]
    except:
        raise HTTP(400)

    gtable = s3db.gis_location
    query = (gtable.id == id)
    row = db(query).select(gtable.name,
                           gtable.level,
                           gtable.parent,
                           gtable.L0,
                           gtable.L1,
                           gtable.L2,
                           gtable.L3,
                           limitby=(0, 1)).first()
    if not row or not row.level:
        return ""
    script = ""
    data = dict(
            n = row.name,
            l = int(row.level[1]),
            f = row.parent,
            )
    vdata = {}
    ids = []
    append = ids.append
    level = row.level
    l0_name = row.L0
    l1_name = row.L1
    l2_name = row.L2
    l3_name = row.L3
    stable = s3db.stats_aggregate
    vtable = s3db.vulnerability_data
    srctable = s3db.doc_source_entity
    resilience_id = s3db.vulnerability_resilience_id()
    if level != "L4":
        # We need to read the names & resilience of the next level down for the popup dropdown selector
        _level = int(level[1]) + 1
        query = (gtable.parent == id) & \
                (gtable.level == "L%s" % _level) & \
                (gtable.deleted != True)
        lquery = (stable.parameter_id == resilience_id) & \
                 (stable.agg_type == 4) & \
                 (stable.location_id == gtable.id)
        left = stable.on(lquery)
        rows = db(query).select(gtable.id,
                                gtable.name,
                                stable.date,
                                stable.mean,
                                orderby=~stable.date,
                                left=left)
        for row in rows:
            _id = row[gtable].id
            if _id in ids:
                # We're only interested in the most recent data per location
                continue
            append(_id)
            mean = row[stable].mean
            if mean is None:
                resilience = 0
            else:
                resilience = int(round(mean, 0))
            vdata[_id] = dict(r = resilience,
                              n = row[gtable].name,
                              l = _level,
                              f = id,
                              )
        # Total number of L4s in this region
        # @ToDo: Below L0 we cannot guarantee uniqueness of Lx names
        query = (gtable.level == "L4") & \
                (gtable.deleted != True)
        if level == "L0":
            query = query & (gtable.L0 == l0_name)
        elif level == "L1":
            query = query & (gtable.L0 == l0_name) & \
                            (gtable.L1 == l1_name)
        elif level == "L2":
            query = query & (gtable.L0 == l0_name) & \
                            (gtable.L1 == l1_name) & \
                            (gtable.L2 == l2_name)
        elif level == "L3":
            query = query & (gtable.L0 == l0_name) & \
                            (gtable.L1 == l1_name) & \
                            (gtable.L2 == l2_name) & \
                            (gtable.L3 == l3_name)
        ids = db(query).select(gtable.id)
        t = len(ids)
        # How many L4s have reported?
        query = vtable.location_id.belongs([r.id for r in ids])
        rows = db(query).select(vtable.location_id,
                                distinct=True)
        count = len(rows)
        data["c"] = count
        data["t"] = t
        # Calculate Quality
        if count == 0 or t == 0:
            q = "p"
        else:
            q = count/t * 100
            if q < 25:
                q = "p"
            elif q < 50:
                q = "f"
            elif q < 75:
                q = "m"
            else:
                q = "s"
        data["q"] = q

    else:
        # We are an L4 already
        # Last Data Collected on t by c
        # @ToDo: This probably won't be the correct person & if it is, it will need formatting using s3_fullname
        query = (vtable.location_id == id) & \
                (vtable.location_id == id)
        row = db(query).select(vtable.date,
                               srctable.created_by)
        data["t"] = row[vtable].date
        data["c"] = row[srctable].created_by

    # Get the Resilience
    query = (stable.parameter_id == resilience_id) & \
            (stable.agg_type == 4) & \
            (stable.location_id == id)
    r = db(query).select(stable.date,
                         stable.mean,
                         orderby=~stable.date,
                         limitby=(0, 1)).first()
    if not r or r.mean is None:
        resilience = 0
    else:
        resilience = int(round(r.mean, 0))
    data["r"] = resilience

    # Get the list of indicators
    indicator_pids = s3db.vulnerability_ids()
    # Get the aggregated data for this location for all indicators
    query = (stable.location_id == id) & \
            (stable.parameter_id.belongs(indicator_pids))
    rows = db(query).select(stable.parameter_id,
                            stable.min,
                            stable.max,
                            stable.median)
    indicator_data = {}
    for row in rows:
        indicator_data[row.parameter_id] = dict(
                        min = row.min,
                        max = row.max,
                        median = row.median,
                       )
    data["i"] = indicator_data

    # Get the Demographic data for the location
    dtable = s3db.stats_demographic
    ddtable = s3db.stats_demographic_data
    query = (dtable.name == "Population") & \
            (ddtable.location_id == id) & \
            (ddtable.parameter_id == dtable.parameter_id) & \
            (ddtable.source_id == srctable.source_id)
    row = db(query).select(ddtable.value,
                           srctable.name,
                           orderby=~ddtable.date,
                           limitby=(0, 1)).first()
    if row:
        p = row[ddtable].value
        if p:
            p = int(p)
        data["p"] = p
        data["s"] = row[srctable].name
    else:
        data["p"] = ""
        data["s"] = ""
    if level == "L4":
        # Add breakdowns
        query = (dtable.name != "Population") & \
                (ddtable.location_id == id) & \
                (ddtable.parameter_id == dtable.parameter_id) & \
                (ddtable.source_id == srctable.source_id)
        rows = db(query).select(dtable.id,
                                dtable.name,
                                ddtable.value,
                                ddtable.date,
                                srctable.name,
                                orderby=~ddtable.date
                                )
        b = {}
        ids = []
        append = ids.append
        for row in rows:
            id = row[dtable].id
            if id in ids:
                # We're only interested in the most recent data per demographic
                continue
            append(id)
            b[row[dtable].id] = dict(
                    n = row[dtable].name,
                    v = row[ddtable].value,
                    s = row[srctable].name,
                )
        data["b"] = b

    vdata[id] = data
    script = '''n=%s\n''' % json.dumps(vdata)
    response.headers["Content-Type"] = "application/json"
    return script

# -----------------------------------------------------------------------------
def reportFilter(filter_request):
    """
        Helper function to extract the selections from the side panel
        and generate a resource filter
        @todo: add filter for MY REPORTS
    """

    doctable = s3db.doc_source_entity
    doctype = s3db.doc_source_type
    query = (doctable.deleted != True) & (doctable.source_type_id == doctype.id)
    try:
        loc_id = int(filter_request["location_id"])
    except:
        loc_id = -1
    if loc_id != -1:
        query &= (doctable.location_id == loc_id)
    if filter_request["from_date"]:
        query &= (doctable.date >= filter_request["from_date"])
    if filter_request["to_date"]:
        query &= (doctable.date <= filter_request["to_date"])
    indicator = None
    if "indicator" in filter_request:
        indicator = (doctype.name == "vulnerability_indicator")
    if "demographics" in filter_request:
        if indicator:
            indicator |= (doctype.name == "stats_demographic")
        else:
            indicator = (doctype.name == "stats_demographic")
    if "map" in filter_request:
        if indicator:
            indicator |= (doctype.name == "stats_map")
        else:
            indicator = (doctype.name == "stats_map")
    if "images" in filter_request:
        if indicator:
            indicator |= (doctype.name == "stats_image")
        else:
            indicator = (doctype.name == "stats_image")
    if "reports" in filter_request:
        if indicator:
            indicator |= (doctype.name == "stats_other")
        else:
            indicator = (doctype.name == "stats_other")
    if indicator:
        query &= indicator
    return query
    # End of reportFilter ------------------------------------------------

    def reportDataTable(request):
        """
            Helper function to return the dataTable that uses the selected
            filter options
        """
        from s3.s3utils import S3DataTable
        doctable = s3db.doc_source_entity
        #-----------------------------------------------------------------
        # Set up custom represents
        #-----------------------------------------------------------------
        def location_repr(id):
            """
                Return the location name (commune) wrapped in a span
            """
            if not id:
                repr_text = current.messages.NONE
            else:
                db = current.db
                table = db.gis_location
                row = db(table.id == id).select(table.name,
                                                limitby=(0, 1)).first()
                if not row:
                    repr_text = current.messages.UNKNOWN_OPT
                repr_text = row.name
            return SPAN(repr_text, _class = "communeCell")

        def submitted_repr(id):
            """
                Return the initial of the first name and the complete last name
            """
            if not id:
                repr_text = current.messages.NONE
            else:
                db = current.db
                table = db.pr_person
                row = db(table.id == id).select(table.first_name,
                                                table.last_name,
                                                limitby=(0, 1)).first()
                if not row:
                    repr_text = current.messages.UNKNOWN_OPT
                repr_text = "%s. %s" % (row.first_name[0], row.last_name)
            return repr_text

        def approved_repr(id):
            """
                Return the initials of the first and the last name
            """
            if not id:
                repr_text = T("Approval pending")
            else:
                db = current.db
                table = db.pr_person
                row = db(table.id == id).select(table.first_name,
                                                table.last_name,
                                                limitby=(0, 1)).first()
                if not row:
                    repr_text = current.messages.UNKNOWN_OPT
                repr_text = "Approved by %s. %s" % (row.first_name[0], row.last_name[0])
            return repr_text

        def action_repr(id):
            """
                Return the initials of the first and the last name
            """
            if not id:
                repr_text = current.messages.NONE
            else:
                repr_text = A("Review",
                                  _class = "reviewButton",
                                  _href = "#reports?id=%s" % id
                                  )
                repr_text.append(A("Close",
                                   _class = "closeReviewButton",
                                   _href = "#reports"
                                   ))
            return repr_text
        doctable.location_id.represent = location_repr
        doctable.created_by.represent = submitted_repr
        doctable.modified_by.represent = approved_repr
        doctable.id.represent = action_repr

        filter_request = request.post_vars
        filter = reportFilter(filter_request)
        resource = current.manager.define_resource("doc", "source_entity")
        resource.add_filter(filter)
        filteredrows = resource.count()
        #############################################################
        # Note if list_fields is changed here then it also needs
        # to be changed in index, where the table is initialised
        #############################################################
        list_fields = [("Action", "id"),
                       ("Date", "date"),
                       ("Commune Name", "location_id"),
                       "location_id$L3",
                       "status",
                       ("Type", "source_type_id"),
                       ("Submitted by", "created_by"),
                       ("Status", "modified_by"),
                       ]
        rows = resource.select(list_fields,
                               orderby=~doctable.date,
                               start=0,
                               limit=filteredrows,
                               )
        data = resource.extract(rows,
                                list_fields,
                                represent=True,
                                )
        type_totals = {}
        for item in data:
            if item.status in type_totals:
                type_totals[item.status] += 1
            else:
                type_totals[item.status] = 1
        rfields = resource.resolve_selectors(list_fields)[0]
        dt = S3DataTable(rfields, data)
        dt.defaultActionButtons(resource)
        if request.extension == "html":
            report = dt.html(#filteredrows,
                             #filteredrows,
                             "report",
                             dt_pagination="false",
                             dt_bFilter="false",
                             dt_sDom="t",
                             dt_group=[3,4],
                             dt_group_totals=[type_totals],
                             dt_ajax_url=URL(c="vulnerability",
                                             f="report",
                                             extension="aaData",
                                             vars={"id": "report"},
                                             ),
                             dt_action_col = -1,
                             dt_shrink_groups = "accordion"
                             )
        else:
            indicator = (doctype.name == "stats_map")
    if "images" in filter_request:
        if indicator:
            indicator |= (doctype.name == "stats_image")
        else:
            indicator = (doctype.name == "stats_image")
    if "reports" in filter_request:
        if indicator:
            indicator |= (doctype.name == "stats_other")
        else:
            indicator = (doctype.name == "stats_other")
    if indicator:
        query &= indicator
    return query

# -----------------------------------------------------------------------------
def reportDataTable(request):
    """
        Helper function to return the dataTable that uses the selected
        filter options
    """
    from s3.s3utils import S3DataTable
    doctable = s3db.doc_source_entity
    #-----------------------------------------------------------------
    # Set up custom represents
    #-----------------------------------------------------------------
    def location_repr(id):
        """
            Return the location name (commune) wrapped in a span
        """
        if not id:
            repr_text = current.messages.NONE
        else:
            db = current.db
            table = db.gis_location
            row = db(table.id == id).select(table.name,
                                            limitby=(0, 1)).first()
            if not row:
                repr_text = current.messages.UNKNOWN_OPT
            repr_text = row.name
        return SPAN(repr_text, _class="communeCell")

    def submitted_repr(id):
        """
            Return the initial of the first name and the complete last name
        """
        if not id:
            repr_text = current.messages.NONE
        else:
            db = current.db
            table = db.pr_person
            row = db(table.id == id).select(table.first_name,
                                            table.last_name,
                                            limitby=(0, 1)).first()
            if row:
                repr_text = "%s. %s" % (row.first_name[0], row.last_name)
            else:
                repr_text = current.messages.UNKNOWN_OPT
        return repr_text

    def approved_repr(id):
        """
            Return the initials of the first and the last name
        """
        if not id:
            repr_text = T("Approval pending")
        else:
            db = current.db
            table = db.pr_person
            row = db(table.id == id).select(table.first_name,
                                            table.last_name,
                                            limitby=(0, 1)).first()
            if row:
                repr_text = T("Approved by %(first_initial)s.%(last_initial)s") % \
                    dict(first_initial = row.first_name[0],
                         last_initial = row.last_name[0])
            else:
                repr_text = current.messages.UNKNOWN_OPT
        return repr_text

    def action_repr(id):
        """
            Return the initials of the first and the last name
        """
        if not id:
            repr_text = current.messages.NONE
        else:
            repr_text = A(T("Review"),
                          _class = "reviewButton",
                          _href = "#reports?id=%s" % id
                          )
            repr_text.append(A(T("Close"),
                               _class = "closeReviewButton",
                               _href = "#reports"
                               ))
        return repr_text

    doctable.location_id.represent = location_repr
    doctable.created_by.represent = submitted_repr
    doctable.modified_by.represent = approved_repr
    doctable.id.represent = action_repr

    filter_request = request.post_vars
    filter = reportFilter(filter_request)
    resource = s3db.resource("doc_source_entity")
    resource.add_filter(filter)
    filteredrows = resource.count()
    #############################################################
    # Note if list_fields is changed here then it also needs
    # to be changed in index, where the table is initialised
    #############################################################
    list_fields = [(T("Action"), "id"),
                   (T("Date"), "date"),
                   (T("Commune Name"), "location_id"),
                   "location_id$L3",
                   "status",
                   (T("Type"), "source_type_id"),
                   (T("Submitted by"), "created_by"),
                   (T("Status"), "modified_by"),
                   ]
    rows = resource.select(list_fields,
                           orderby=~doctable.date,
                           start=0,
                           limit=filteredrows,
                           )
    data = resource.extract(rows,
                            list_fields,
                            represent=True,
                            )
    type_totals = {}
    for item in data:
        status = item["doc_source_entity.status"]
        if status in type_totals:
            type_totals[status] += 1
        else:
            type_totals[status] = 1
    rfields = resource.resolve_selectors(list_fields)[0]
    dt = S3DataTable(rfields, data)
    dt.defaultActionButtons(resource)
    if request.extension == "html":
        report = dt.html(#filteredrows,
                         #filteredrows,
                         "report",
                         dt_pagination = "false",
                         dt_bFilter = "false",
                         dt_sDom = "t",
                         dt_group = [3, 4],
                         dt_group_totals = [type_totals],
                         dt_ajax_url = URL(c="vulnerability",
                                           f="report",
                                           extension="aaData",
                                           vars={"id": "report"},
                                           ),
                         dt_action_col = -1,
                         dt_shrink_groups = "accordion"
                         )
    else:
        report = dt.json("report",
                         int(request.vars.sEcho),
                         filteredrows,
                         filteredrows,
                         dt_group_totals=[type_totals],
                         )
    return str(report)

# -----------------------------------------------------------------------------
def report():
    """ Not a REST Controller """

    s3.no_formats = True
    if request.args(0) == "filter":
        report = reportDataTable(request)
        data = json.dumps(report)
    else:
        filter = {}
        date_widget = S3DateWidget(format="yy-mm-dd", future=0)
        to_date = Field("to_date")
        to_date._tablename = ""
        from_date = Field("from_date")
        from_date._tablename = ""
        filter["to_date"] = str(date_widget(to_date, None))
        filter["from_date"] = str(date_widget(from_date, None))
        report = reportDataTable(request)
        data_dict = {"filter" : filter,
                     "report" : report,
                     }
        data = json.dumps(data_dict)

    response.headers["Content-Type"] = "application/json"
    return data

# -----------------------------------------------------------------------------
def indicator():
    """ REST Controller """

    return s3_rest_controller()

# -----------------------------------------------------------------------------
def aggregated_indicator():
    """ REST Controller """

    return s3_rest_controller()

# -----------------------------------------------------------------------------
def data():
    """ REST Controller """

    return s3_rest_controller()

# END =========================================================================
